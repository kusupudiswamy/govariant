# A generator for Go(lang) sum types

Go doesn't have sum types. We emulate them -- most often using the empty
`interface{}` in conjunction with a type switch. And that works fine.

Still... I wanted to try out another way of doing this -- and write a code
generator for it, which is all the rage. Accidentally, it is the ideal case for
a simple code generator, as it requires writing `O(n^2)` methods for a type
with `n` variants.

The basic idea is to encode a sum type with an interface with one method
corresponding to each variant. Those methods are named after the variant type
and return both a value of it and a boolean. The return values correspond to a
type assertion.

Why bother? Well, the sum type then documents exactly what variants it
contains (not true when using `interface{}`).

Also, since it's an interface it's possible for types other than the variants
to implement them. And there is one use case I can think of for that --
exhaustiveness checking in tests.

However, this approach has drawbacks and limitations. We can't define methods
on builtin types or interfaces, so they cannot be variants if we want all
methods to be auto-generated.

And since the actual type is an interface, the language considers nil a
permissible value.

# How to use it

First of all, it expects to be run by `go generate`. If you do it by hand, set
the value of the `GOPACKAGE` environment variable and run it in the right
directory. Having said that, a

```go
//go:generate govariant Sum X Y Z
```

should generate the code for the type Sum of which X, Y and Z are variants in
the file `Sum_variant.go`.

# Example

For the following code and generate directive

```go
package example

//go:generate govariant Shape Circle Rectangle

type Cirlce struct {
	Center Point
	Radius float64
}

type Rectangle struct {
	LowerLeft     Point
	Width, Height float64
}

type Point struct {
	X, Y float64
}
```

you should get a file called `Shape_variant.go` with the following contents

```go
package example

// A Shape is one of
//
//     - Circle
//     - Rectangle
type Shape interface {
	Circle() (Circle, bool)
	Rectangle() (Rectangle, bool)
}

// A ShapeExhaustive is a Shape that can be used to check
// exhaustivity in tests
type ShapeExhaustive struct {
	Shape

	CircleCalled    bool
	RectangleCalled bool
}

// Checks whether all the variants of the Shape were considered.
func (se ShapeExhaustive) Exhaustive() bool {

	if !se.CircleCalled {
		return false
	}

	if !se.RectangleCalled {
		return false
	}

	return true
}

// Circle implements the corresponding method of Shape on the Circle type.
func (sv Circle) Circle() (Circle, bool) {
	return sv, true
}

// Rectangle implements the corresponding method of Shape on the Circle type.
func (_ Circle) Rectangle() (Rectangle, bool) {
	var v Rectangle
	return v, false
}

// Circle implements the corresponding method of Shape on the Rectangle type.
func (_ Rectangle) Circle() (Circle, bool) {
	var v Circle
	return v, false
}

// Rectangle implements the corresponding method of Shape on the Rectangle type.
func (sv Rectangle) Rectangle() (Rectangle, bool) {
	return sv, true
}
```
