# A generator for Go(lang) sum types

Go doesn't have sum types. We emulate them -- most often using the empty
`interface{}` in conjunction with a type switch. And that works fine.

Still... I wanted to try out another way of doing this -- and write a code
generator for it, which is all the rage. Accidentally, it is the ideal case for
a simple code generator, as it requires writing repetitive methods on several
types.

The basic idea is to encode a sum type with an interface with one method
corresponding to each variant. Those methods are named after the variant type
and return both a value of it and a boolean. The return values correspond to a
type assertion. For each variant we also add a method that converts it to the
sum type.

However, this approach has drawbacks and limitations. We can't define methods
on builtin types, types imported from other packages or interfaces, so they
cannot be variants if we want all methods to be auto-generated.

And since the actual type is an interface, the language considers nil a
permissible value.

# How to use it

First of all, it expects to be run by `go generate`. If you do it by hand, set
the value of the `GOPACKAGE` environment variable and run it in the right
directory. Having said that, a

```go
//go:generate govariant Sum X Y Z
```

should generate the code for the type Sum of which X, Y and Z are variants in
the file `Sum_variant.go`.

# Example

For the following code and generate directive

```go
package example

//go:generate govariant Shape Circle Rectangle

type Cirlce struct {
	Center Point
	Radius float64
}

type Rectangle struct {
	LowerLeft     Point
	Width, Height float64
}

type Point struct {
	X, Y float64
}
```

you should get a file called `Shape_variant.go` with the following contents

```go
package example

// A Shape is one of
//
//     - Circle
//     - Rectangle
//
// In each implementation exactly one of the methods should have the second
// return value be true.
type Shape interface {

	// Circle returns a Circle and a boolean. When the second return value is true,
	// the Shape is the returned Circle.
	Circle() (Circle, bool)

	// Rectangle returns a Rectangle and a boolean. When the second return value is true,
	// the Shape is the returned Rectangle.
	Rectangle() (Rectangle, bool)
}

// A coreShape provides default implementations for the methods of a
// Shape. The wrapper types only redefine the one for the associated variant.
type coreShape struct{}

func (_ coreShape) Circle() (Circle, bool) {
	var v Circle
	return v, false
}

func (_ coreShape) Rectangle() (Rectangle, bool) {
	var v Rectangle
	return v, false
}

// Shape converts a Circle to an instance of the sum type Shape.
func (v Circle) Shape() Shape {
	return wrapCircleShape{
		wrappedCircle: v,
	}
}

type wrapCircleShape struct {
	coreShape
	wrappedCircle Circle
}

func (w wrapCircleShape) Circle() (Circle, bool) {
	return w.wrappedCircle, true
}

// Shape converts a Rectangle to an instance of the sum type Shape.
func (v Rectangle) Shape() Shape {
	return wrapRectangleShape{
		wrappedRectangle: v,
	}
}

type wrapRectangleShape struct {
	coreShape
	wrappedRectangle Rectangle
}

func (w wrapRectangleShape) Rectangle() (Rectangle, bool) {
	return w.wrappedRectangle, true
}
```
